<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bulk Image Resizer (Subject Center + No Stretch)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:18px;color:#111}
    .topbar{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h2{margin:0}
    .credit{font-size:12px;color:#666;white-space:nowrap}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:end;margin-top:10px}
    label{display:flex;flex-direction:column;gap:6px;font-size:13px}
    input[type="number"], select, input[type="color"] {padding:8px 10px;border:1px solid #ccc;border-radius:10px;min-width:160px}
    input[type="color"]{min-width:120px;padding:6px 8px;height:38px}
    input[type="file"]{padding:8px 0}
    button{padding:10px 14px;border:0;border-radius:12px;background:#111;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .hint{font-size:12px;color:#444;line-height:1.4;margin-top:8px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px;margin-top:16px}
    .card{border:1px solid #e5e5e5;border-radius:16px;padding:12px}
    .card h4{margin:0 0 8px 0;font-size:14px}
    .thumb{width:100%;aspect-ratio:1/1;border-radius:14px;background:#f3f3f3;display:block;object-fit:cover}
    .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .small{font-size:12px;color:#333}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid #ddd;border-radius:999px;font-size:12px}
    .bar{height:10px;background:#eee;border-radius:999px;overflow:hidden}
    .bar > div{height:100%;background:#111;width:0%}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
    .hidden{display:none !important}
    .inline{display:flex;gap:10px;align-items:center}
    .check{display:flex;gap:8px;align-items:center;font-size:13px;color:#222;margin-bottom:2px}
    .check input{transform:translateY(1px)}
  </style>
</head>
<a href="../index.html">← Back to Home</a>
<body>

  <div class="topbar">
    <h2>Bulk Resizer (Subject Center + No Stretch)</h2>
    <div class="credit">© <span id="year"></span> Designed by <b>Rahul Negi</b></div>
  </div>

  <div class="row">
    <label>
      Upload images (bulk)
      <input id="files" type="file" accept="image/*" multiple />
    </label>

    <label>
      Output width (px)
      <input id="outW" type="number" min="64" step="1" value="1080" />
    </label>

    <label>
      Output height (px)
      <input id="outH" type="number" min="64" step="1" value="1080" />
    </label>

    <label class="check" style="min-width:160px">
      <span>
        <input id="lockSquare" type="checkbox" checked />
        Lock square (W = H)
      </span>
    </label>

    <label>
      Mode
      <select id="mode">
        <option value="smartCrop">Smart Crop (fit exact size)</option>
        <option value="blurPad">Blur Pad (no stretch)</option>
        <option value="mirrorPad">Mirror Pad (no stretch)</option>
        <option value="colorPad">Color Pad (no stretch)</option>
      </select>
    </label>

    <label id="bgColorWrap" class="hidden">
      Background color
      <input id="bgColor" type="color" value="#ffffff" />
    </label>

    <label>
      JPG quality (0.6–1)
      <input id="quality" type="number" min="0.6" max="1" step="0.05" value="0.9" />
    </label>

    <button id="processBtn" disabled>Resize</button>
    <button id="zipBtn" disabled>Download ZIP</button>
  </div>

  <div class="hint">
    <div class="pill">✅ Subject center: edges/saliency heuristic</div>
    <div class="pill">✅ Custom size support</div>
    <div class="pill">✅ No stretch options</div>
    <div style="margin-top:8px">
      Tip: Exact custom size chahiye ho to <b>Smart Crop</b>. Cut nahi karna ho to <b>Blur/Mirror/Color Pad</b>.
    </div>
  </div>

  <div style="margin-top:14px" class="bar" aria-label="progress"><div id="prog"></div></div>
  <div id="status" class="small" style="margin-top:8px"></div>

  <div id="grid" class="grid"></div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    const filesEl = document.getElementById('files');
    const processBtn = document.getElementById('processBtn');
    const zipBtn = document.getElementById('zipBtn');
    const grid = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const progEl = document.getElementById('prog');

    const modeEl = document.getElementById('mode');
    const bgColorWrap = document.getElementById('bgColorWrap');
    const bgColorEl = document.getElementById('bgColor');

    const outWEl = document.getElementById('outW');
    const outHEl = document.getElementById('outH');
    const lockSquareEl = document.getElementById('lockSquare');

    document.getElementById("year").textContent = new Date().getFullYear();

    let results = [];

    function refreshBgColorVisibility() {
      bgColorWrap.classList.toggle('hidden', modeEl.value !== 'colorPad');
    }
    refreshBgColorVisibility();
    modeEl.addEventListener('change', refreshBgColorVisibility);

    function syncSquare(from) {
      if (!lockSquareEl.checked) return;
      if (from === 'w') outHEl.value = outWEl.value;
      if (from === 'h') outWEl.value = outHEl.value;
    }
    outWEl.addEventListener('input', () => syncSquare('w'));
    outHEl.addEventListener('input', () => syncSquare('h'));
    lockSquareEl.addEventListener('change', () => syncSquare('w'));

    filesEl.addEventListener('change', () => {
      results = [];
      grid.innerHTML = '';
      statusEl.textContent = '';
      progEl.style.width = '0%';
      processBtn.disabled = !(filesEl.files && filesEl.files.length);
      zipBtn.disabled = true;
    });

    processBtn.addEventListener('click', async () => {
      const files = [...filesEl.files];

      const outW = clampInt(parseInt(outWEl.value, 10) || 1080, 64, 12000);
      const outH = clampInt(parseInt(outHEl.value, 10) || 1080, 64, 12000);

      const mode = modeEl.value;
      const quality = clamp(parseFloat(document.getElementById('quality').value) || 0.9, 0.6, 1);
      const bgColor = (bgColorEl && bgColorEl.value) ? bgColorEl.value : "#ffffff";

      results = [];
      grid.innerHTML = '';
      zipBtn.disabled = true;

      statusEl.innerHTML = `<span class="mono">Processing ${files.length} image(s)...</span>`;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        try {
          const img = await fileToImage(file);
          const out = await renderCustom(img, outW, outH, mode, quality, bgColor);
          results.push({ name: safeName(file.name, mode, outW, outH), blob: out.blob, url: out.url });
          addCard(file.name, out.url, out.blob.size, mode, outW, outH);
        } catch (e) {
          addErrorCard(file.name, e);
        }

        const pct = Math.round(((i+1)/files.length)*100);
        progEl.style.width = pct + '%';
        statusEl.innerHTML = `<span class="mono">Done ${i+1}/${files.length}</span>`;
        await sleep(10);
      }

      zipBtn.disabled = results.length === 0;
      statusEl.innerHTML += results.length ? ` — <b>Ready</b>` : ` — <b>No outputs</b>`;
    });

    zipBtn.addEventListener('click', async () => {
      if (!results.length) return;

      zipBtn.disabled = true;
      statusEl.innerHTML = `<span class="mono">Creating ZIP...</span>`;

      const zip = new JSZip();
      for (const r of results) zip.file(r.name, r.blob);

      const zipBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
        progEl.style.width = Math.round(meta.percent) + '%';
      });

      downloadBlob(zipBlob, `resized_${Date.now()}.zip`);
      statusEl.innerHTML = `<span class="mono">ZIP downloaded</span>`;
      zipBtn.disabled = false;
    });

    // ---------------- Core ----------------
    async function renderCustom(img, outW, outH, mode, quality, bgColor) {
      const canvas = document.createElement('canvas');
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const center = estimateSubjectCenter(img);

      if (mode === 'smartCrop') {
        // Crop to target aspect ratio around subject center, then scale to output
        const rect = cropToAspectRect(img.width, img.height, outW / outH, center.x, center.y);
        ctx.drawImage(img, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, outW, outH);

      } else if (mode === 'blurPad') {
        // Background cover + blur
        const bg = coverRect(img.width, img.height, outW, outH);
        ctx.filter = 'blur(22px)';
        ctx.drawImage(img, bg.sx, bg.sy, bg.sw, bg.sh, 0, 0, outW, outH);
        ctx.filter = 'none';

        ctx.globalAlpha = 0.10;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, outW, outH);
        ctx.globalAlpha = 1;

        // Foreground contain
        const fg = containRect(img.width, img.height, outW, outH);
        const shift = subjectShift(img.width, img.height, outW, outH, center, fg);
        const dx = clamp(shift.dx, -outW * 0.15, outW * 0.15);
        const dy = clamp(shift.dy, -outH * 0.15, outH * 0.15);

        ctx.drawImage(img, 0, 0, img.width, img.height, fg.dx + dx, fg.dy + dy, fg.dw, fg.dh);

      } else if (mode === 'mirrorPad') {
        drawMirrorBackground(ctx, img, outW, outH);

        const fg = containRect(img.width, img.height, outW, outH);
        const shift = subjectShift(img.width, img.height, outW, outH, center, fg);
        const dx = clamp(shift.dx, -outW * 0.15, outW * 0.15);
        const dy = clamp(shift.dy, -outH * 0.15, outH * 0.15);

        ctx.drawImage(img, 0, 0, img.width, img.height, fg.dx + dx, fg.dy + dy, fg.dw, fg.dh);

      } else if (mode === 'colorPad') {
        ctx.fillStyle = bgColor || "#ffffff";
        ctx.fillRect(0, 0, outW, outH);

        const fg = containRect(img.width, img.height, outW, outH);
        const shift = subjectShift(img.width, img.height, outW, outH, center, fg);
        const dx = clamp(shift.dx, -outW * 0.15, outW * 0.15);
        const dy = clamp(shift.dy, -outH * 0.15, outH * 0.15);

        ctx.drawImage(img, 0, 0, img.width, img.height, fg.dx + dx, fg.dy + dy, fg.dw, fg.dh);
      }

      const blob = await new Promise((res) => canvas.toBlob(res, 'image/jpeg', quality));
      const url = URL.createObjectURL(blob);
      return { blob, url };
    }

    // Crop source image to target aspect ratio around center
    function cropToAspectRect(iw, ih, targetAR, centerX, centerY) {
      const srcAR = iw / ih;
      let sw, sh;

      if (srcAR > targetAR) {
        // source too wide -> crop width
        sh = ih;
        sw = Math.round(ih * targetAR);
      } else {
        // source too tall -> crop height
        sw = iw;
        sh = Math.round(iw / targetAR);
      }

      let sx = Math.round(centerX - sw/2);
      let sy = Math.round(centerY - sh/2);

      sx = clampInt(sx, 0, iw - sw);
      sy = clampInt(sy, 0, ih - sh);

      return { sx, sy, sw, sh };
    }

    // ---------------- Subject center estimation ----------------
    function estimateSubjectCenter(img) {
      const maxDim = 256;
      const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
      const w = Math.max(1, Math.round(img.width * scale));
      const h = Math.max(1, Math.round(img.height * scale));

      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const x = c.getContext('2d', { willReadFrequently: true });
      x.drawImage(img, 0, 0, w, h);

      const { data } = x.getImageData(0, 0, w, h);

      const gray = new Float32Array(w * h);
      for (let i = 0; i < w*h; i++) {
        const r = data[i*4], g = data[i*4+1], b = data[i*4+2];
        gray[i] = 0.2126*r + 0.7152*g + 0.0722*b;
      }

      let sumW = 0, sumX = 0, sumY = 0;
      for (let y = 1; y < h-1; y++) {
        for (let x0 = 1; x0 < w-1; x0++) {
          const gx =
            -gray[(y-1)*w + (x0-1)] + gray[(y-1)*w + (x0+1)] +
            -2*gray[y*w + (x0-1)]     + 2*gray[y*w + (x0+1)] +
            -gray[(y+1)*w + (x0-1)] + gray[(y+1)*w + (x0+1)];

          const gy =
            -gray[(y-1)*w + (x0-1)] - 2*gray[(y-1)*w + x0] - gray[(y-1)*w + (x0+1)] +
             gray[(y+1)*w + (x0-1)] + 2*gray[(y+1)*w + x0] + gray[(y+1)*w + (x0+1)];

          let mag = Math.abs(gx) + Math.abs(gy);

          const cx = w/2, cy = h/2;
          const dx = (x0 - cx) / cx;
          const dy = (y - cy) / cy;
          const centerBias = 1 - 0.35 * (dx*dx + dy*dy);
          mag *= Math.max(0.2, centerBias);

          if (mag < 30) continue;

          sumW += mag;
          sumX += x0 * mag;
          sumY += y * mag;
        }
      }

      let cx = w/2, cy = h/2;
      if (sumW > 1) { cx = sumX / sumW; cy = sumY / sumW; }
      return { x: cx / scale, y: cy / scale };
    }

    // ---------------- Mirror background ----------------
    function drawMirrorBackground(ctx, img, tw, th) {
      const bg = coverRect(img.width, img.height, tw, th);
      ctx.globalAlpha = 0.95;
      ctx.drawImage(img, bg.sx, bg.sy, bg.sw, bg.sh, 0, 0, tw, th);
      ctx.globalAlpha = 1;

      const fg = containRect(img.width, img.height, tw, th);

      if (fg.dx > 0) {
        ctx.save();
        ctx.translate(fg.dx, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, fg.dy, fg.dw, fg.dh);
        ctx.restore();
      }

      const rightGap = tw - (fg.dx + fg.dw);
      if (rightGap > 0) {
        ctx.save();
        ctx.translate(fg.dx + fg.dw, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, img.width, img.height, -fg.dw, fg.dy, fg.dw, fg.dh);
        ctx.restore();
      }

      if (fg.dy > 0) {
        ctx.save();
        ctx.translate(0, fg.dy);
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, 0, img.width, img.height, fg.dx, 0, fg.dw, fg.dh);
        ctx.restore();
      }

      const bottomGap = th - (fg.dy + fg.dh);
      if (bottomGap > 0) {
        ctx.save();
        ctx.translate(0, fg.dy + fg.dh);
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, 0, img.width, img.height, fg.dx, -fg.dh, fg.dw, fg.dh);
        ctx.restore();
      }
    }

    // ---------------- Geometry ----------------
    function coverRect(iw, ih, tw, th) {
      const ir = iw / ih;
      const tr = tw / th;
      let sw, sh, sx, sy;

      if (ir > tr) {
        sh = ih;
        sw = Math.round(ih * tr);
        sx = Math.round((iw - sw) / 2);
        sy = 0;
      } else {
        sw = iw;
        sh = Math.round(iw / tr);
        sx = 0;
        sy = Math.round((ih - sh) / 2);
      }
      return { sx, sy, sw, sh };
    }

    function containRect(iw, ih, tw, th) {
      const scale = Math.min(tw / iw, th / ih);
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);
      const dx = Math.round((tw - dw) / 2);
      const dy = Math.round((th - dh) / 2);
      return { sx: 0, sy: 0, sw: iw, sh: ih, dx, dy, dw, dh, scale };
    }

    function subjectShift(iw, ih, tw, th, center, fg) {
      const subjX = fg.dx + center.x * fg.scale;
      const subjY = fg.dy + center.y * fg.scale;
      return { dx: (tw/2 - subjX), dy: (th/2 - subjY) };
    }

    // ---------------- UI helpers ----------------
    function addCard(originalName, previewUrl, bytes, mode, outW, outH) {
      const card = document.createElement('div');
      card.className = 'card';

      card.innerHTML = `
        <h4 title="${escapeHtml(originalName)}">${escapeHtml(originalName)}</h4>
        <img class="thumb" src="${previewUrl}" alt="preview" />
        <div class="small" style="margin-top:8px">
          <span class="pill">Mode: <b>${mode}</b></span>
          <span class="pill">${outW}×${outH}</span>
          <span class="pill">${formatBytes(bytes)}</span>
        </div>
        <div class="actions">
          <button class="dlBtn">Download</button>
          <span class="mono" style="opacity:.7">JPG</span>
        </div>
      `;

      card.querySelector('.dlBtn').addEventListener('click', () => {
        const r = results.find(x => x.url === previewUrl);
        if (r) downloadBlob(r.blob, r.name);
      });

      grid.appendChild(card);
    }

    function addErrorCard(name, err) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <h4>${escapeHtml(name)}</h4>
        <div class="small" style="color:#b00020">Error: ${escapeHtml(String(err))}</div>
      `;
      grid.appendChild(card);
    }

    function fileToImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function downloadBlob(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }

    function safeName(name, mode, w, h) {
      const base = name.replace(/\.[^/.]+$/, '');
      const clean = base.replace(/[^\w\- ]+/g, '_').trim().slice(0, 80);
      return `${clean}_${mode}_${w}x${h}.jpg`;
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function clampInt(v, a, b){ return Math.max(a, Math.min(b, v|0)); }
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    function formatBytes(bytes) {
      const units = ['B','KB','MB','GB'];
      let i = 0; let n = bytes;
      while (n >= 1024 && i < units.length-1){ n/=1024; i++; }
      return `${n.toFixed(i?1:0)} ${units[i]}`;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }
  </script>
</body>
</html>